\subsection{Compteur}
\label{sec:BasicCnt}
Voici la table de vérité d'un simple compteur : 

\begin{table}[ht]
    \centering
    \begin{tabular}{c c c c|c} 
        $arst\_n$ & $clk$ & $srst$ &$en$ & $q_n$ \\ 
        \hline
        0 & *           & * & * & 0 \\
        1 & \risingedge & 1 & * & 0 \\
        1 & \risingedge & 0 & 0 & $q_n$ \\
        1 & \risingedge & 0 & 1 & $q_n + 1$

    \end{tabular}
    \caption{Table de vérité d'un compteur}
    \label{ttab:BasicCnt}
\end{table}

- Implémenter cette table de vérité en VHDL en utilisant un \textit{process} et en \textbf{respectant bien la priorité}. Contraindre le vecteur $q_n$ sur \textbf{8 bits}.

\medskip

- Simuler votre compteur et vérifier que votre implémentation respecte bien la table de vérité.

- Ajouter le paramètre générique $N$ qui permettra de choisir la taille du vecteur $q_n$ lorsqu'on instancie ce compteur.

- Simuler votre compteur pour $N = 7$. A quelle valeur votre compteur reboucle? Pourquoi?

\subsection{Cascade de compteurs}

On veut faire un compteur qui s’incrémente toute les secondes. On veut visualiser ce compteur sur un afficheur sept segments en hexadécimal. Ce compteur devra compter de $0_d$ à $15_d$.

\medskip

- Faire un schéma fonctionnel en faisant apparaître deux compteurs en cascades. \\ 
\textbf{NB: Il est interdit de connecter aux entrées horloges autres que des signaux horloges}.

\medskip

- Implémenter votre schéma fonctionnel en VHDL.

\medskip

- Simuler votre le schema fonctionnel. Pour éviter de simuler une seconde, faire incrémenter le compteur toutes les millisecondes au lieu de toutes les secondes.

\medskip

- Intégrer un analyseur logique (Signal Tap Logic Analyzer) sur votre FPGA et visualiser le signal \textit{q} des compteurs ainsi que le signal \textit{en} du second compteur.

\medskip

- Compiler et programmer. En utilisant l'analyseur logique, déclencher l'acquisition lorsque \textit{en} vaut $1$. Vérifier que \textit{en} est à $1$ que pendant un seul coup d'horloge.

